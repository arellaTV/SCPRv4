require 'open-uri'
##
# Audio
#
# :filename and :store_dir should be present for
# every record, even if it's not live.
#
# :mp3 is only for uploaded and program audio.
# Program audio because we don't want to store all that information
# in the table if we don't have to. The program audio gets
# automatically detected, so we don't have any information about
# it starting out, so we can just use the `mp3` column. For ENCO
# audio, we already have the date and number, so we can just use
# that to get the file.
#
# :enco_number, :enco_date, and :external_url are STI
# columns that can be null depending on audio source
#
# The public API for an audio object should basically be:
# * mp3_file
# * url
# * duration
# * size
# * byline
# * description
#
# Plus a few more things generated by ActiveRecord. See the audio object
# in the KPCC API for what it should be.
# Everything else is really just internal.
#
# `path` is persisted so we don't have to search the filesystem for
# every audio request. This could be a problem if any of the directories
# change - especially a concern for program audio directories. If any of
# those change, you'd just just have to go through each of their audio
# and gsub in the new audio directory. The upside do this is that we no
# longer have to mount the NFS on a server running the app just to *read*
# audio files. We can just point it to the URL of the media server.
class Audio < ActiveRecord::Base
  self.table_name = "media_audio"
  logs_as_task
  has_status


  # Public URL root - http://media.scpr.org/audio
  AUDIO_URL_ROOT = File.join(
    Rails.application.config.scpr.media_url, "audio")

  TIMEOUT = 60


  # The NONE Status is just so we can use Audio::STATUS_TEXT for
  # render the Audio columns in the CMS.
  status :none do
    s.id = nil
    s.text = "None"
    s.unpublished!
  end

  status :waiting do
    s.id = 1
    s.text = "Awaiting Audio"
    s.pending!
  end

  status :live do
    s.id = 2
    s.text = "Live"
    s.published!
  end


  belongs_to :content,
    :polymorphic    => true,
    :touch          => true


  validate :audio_source_is_provided
  validate :enco_info_is_present_together

  validate :path_is_unique, if: -> {
    self.new_record? && self.type == "Audio::UploadedAudio"
  }

  validates :url, url: { allow_blank: true }

  before_save :determine_source

  scope :available,      -> { where(status: Audio.status_id(:live)) }
  scope :awaiting_audio, -> { where(status: Audio.status_id(:waiting)) }


  attr_accessor \
    :mp3,
    :enco_number,
    :enco_date,
    :source


  class << self
    # Compile the full URL to an audio file.
    #
    # Arguments
    # * parts (Strings) - A variable number of strings to build the URL.
    #
    # Example
    #
    #   Audio.url("taketwo", "someaudio.mp3")
    #     #=> http://media.scpr.org/audio/taketwo/someaudio.mp3
    #
    # Returns String
    def url(*parts)
      File.join(AUDIO_URL_ROOT, *parts)
    end
  end


  # Temporary proxy
  def live?
    published?
  end


  # Queue the computation jobs for this audio.
  #
  # Returns nothing.
  def async_compute_file_info
    Resque.enqueue(Job::ComputeAudioFileInfo, self.id)
  end


  # Compute the duration and size of the audio file.
  #
  # Returns nothing.
  def compute_file_info
    compute_duration
    compute_size
    self
  end


  # Compute duration via Mp3Info.
  # Sets duration to 0 if something goes wrong
  # so it's not considered "blank".
  #
  # Returns nothing.
  def compute_duration
    return false if !file

    Mp3Info.open(file) do |file|
      self.duration = file.length
    end

    self.duration ||= 0
  end


  # Compute the size via Carrierwave
  # Sets the value to 0 if something goes wrong
  # so that size won't be "blank".
  #
  # Returns nothing.
  def compute_size
    return false if self.url.blank?
    self.size = file.size || 0
  end


  # Get the actual file via open-uri.
  #
  # Returns Tempfile or nil.
  def file
    return if self.url.blank?

    @file ||= begin
      open(self.url, read_timeout: TIMEOUT)
    rescue OpenURI::HTTPError, Timeout::Error
      nil
    end
  end


  private

  def determine_source
    if self.enco_number.present? && self.enco_date.present?
      # Enco is Awaiting by default.
      # If the audio file already exists on the server,
      # then it will be picked up by the background job
      # and the status will be updated.
      self.source = :enco
      self.status = Audio.status_id(:waiting)

      date = self.enco_date.strftime("%Y%m%d")
      filename = "#{date}_features#{self.enco_number}.mp3"

      self.url = Audio.url("features", filename)

    elsif self.mp3.present?
      # We can assume that if they just uploaded the file,
      # it is available and live.
      self.source = :upload
      self.status = Audio.status_id(:live)

      uploder = AudioUploader.new(self)
      uploader.store!(self.mp3)

      self.url = uploader.url

    elsif self.url.present?
      # Checking for URL should come last so that we can override
      # the existing URL by uploading an mp3 or inputting ENCO info.
      # Let's trust the user to input a correct URL.
      self.source = :direct
      self.status = Audio.status_id(:live)
    end
  end


  def enco_info_is_present_together
    if self.enco_number.blank? ^ self.enco_date.blank?
      errors.add(:base,
        "Enco number and Enco date must both be present for ENCO audio")
      # Just so the form is aware that enco_number and enco_date are involved
      errors.add(:enco_number, "")
      errors.add(:enco_date, "")
    end
  end


  #------------
  # Check if an audio source was given.
  # For the mp3 column, Carrierwave checks that
  # the file actually exists on the filesystem
  # (in `CarrierWave::Uploader::Proxy#blank?`), so
  # we will just check that the column is filled here.
  # If it's filled in but the audio doesn't exist,
  # #mp3_exists will catch that with a more helpful
  # error message.
  def audio_source_is_provided
    if self.url.blank? &&
    self.mp3.file.nil? &&
    self.enco_number.blank? &&
    self.enco_date.blank?
      self.errors.add(:base,
        "Audio must have a source (upload, enco, or URL)")
    end
  end


  # Make sure the audio file has a unique name.
  def path_is_unique
    return true if self.mp3.file.blank?

    # Guess what the audio path will be before it's actually saved there.
    # This is predictable for uploaded audio.
    # This could potentially fail if someone was uploading audio at exactly
    # midnight and some audio already existed for the next day.
    path = File.join(
      AUDIO_PATH_ROOT,
      self.store_dir,
      self.filename
    )

    if File.exist?(path)
      self.errors.add(:mp3,
        "A file with that name already exists; " \
        "please rename your local audio file and try again. " \
        "If you are trying to replace the audio file, first delete the " \
        "old audio.")
    end
  end
end
